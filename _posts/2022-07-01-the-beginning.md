---
layout: post
title: The Beginning
permalink: code/the-beginning
categories: Code
tags: 
---

If you're like me; starting out from the very beginning, with zero formal computer science training, despite having a masters degree in Engineering, there are a certain number of _essential_ things to know and a vast number that you need _to be able_ to learn quickly. Naturally, you wil have begun this journey because you have a vision of what you want to achieve, be it web-development, data-science or software engineering in increasing orders of complexity. But the goal of being a technically capable contractor in even web-development will probably take at least 6 months. Personally, I want to be able to make websites, analyse data and make apps, with a particular focus on analysing data. My impression is that key fundementals are shared between all three.

You should think of the initial learning period as the simple act of getting the information on the internet into your head. Anything you make in this period will be bad or sub-optimal, you don't know enough to build anything resembling usabe software. Make things, purely as a way to learn. The true product of your labour is not the thing you make, but the reference notes you create and the syntax and the methodologies that you learn.

Perhaps I am slow, but I think that a total lack of personalised teaching materials, with a linear progression a huge drain on my time. My experience of coding has been both a mix of both trying to walk before I can run and, of walking when I should be running. You could call these situations, the land of  confusion and the land of stagnation respectively. They are both a serious problem. I am only now approaching the prophecised moment when _it begins to "click"_.

You don't want to be like me, you want it to _"click"_ as soon as possible. The efficiency increase, _"post-clicking"_ is incredible. I believe the solution to "_clicking_" fast lies in the uninspired maxim learning 'the fundementals'. Which begs the question; 'what are the fundementals'?

I'm still not sure if I have 'the fundementals', but as I have been learning, I have documented in real-time the errors and snags I have faced. I have created a bottom-up walk-through of reaching the fundementals. This is not so much a comprehensive database as a story. I have highlighted when something is for all intents and purposes, essential for you to remember.

Therefore I have sorted every piece of syntax into two categories. Some is of course specific to my case of a focus on data and scientific computing. But I think, we desperately need a granualar prescription of facts to learn, rather than an endless of information. Anyway, anything outside of these is two cases not really fundamentals at all:

- __REMEMBER VERBATIM__
- __FOR_REFERENCE__

Most online resources do not convey the relative importance weight of the innumerable pieces of syntax you have to learn and more easily `ctrl-f`'ed for what you need. As we all know, training delivered by committee, without a human to add a personal flair is normally terrible, regardless of the form. That is why up-voted personal opinions on stack-overflow and reddit forums are such powerful tools.

The key problems with most resources are:

- Poor quality: [Spam writing](https://waylonwalker.com/archive/). Most resources are blogs which sacrifice quality for quantity. They are often wrong, written as if in the stream of consciousness of the author or they include [fatal errors](https://medium.com/@joseph.pyram/9-parts-of-a-url-that-you-should-know-89fea8e11713), like specifying the wrong port number. We must distinguish between high effort books, and low effort blog posts.
- Jargon and Grammatical Ambiguity: most _"resources"_ are actually just a vehicle for the author to promote himself and his capabilities, rather than to help the reader. The audience in the author's eyes is a potential employer or customer, who is looking for red-flags or signs of intelligence and dilligence. So they skip over the dirty laymans 'fundementals' and focus some niche topic, using unexplained esoteric terms, that the person reading the article couldn't possibly know. They take shortcuts with their grammar, thinking that the concise-ness improves readability, but the resulting ambiguity, makes it unreadable to anyone who doesn't already understand it. The author's palpable indifference to these complexities is deliberate, and it is to demonstrate their skill and knowledge.
- Excessive Granularity: Certain resources do try to put the reader first, by going in to details, but far too much. Rather than make generalisations, they describe edge cases, exeptions, rare syntax and generally bloat the text with confusion, which detracts from the thread. These explanations are equally unreadable on the first try.
- Lack of specific examples:
- Being out of date. I am sure I am not the first to create a personalised resource of recommendations. But what I am trying to achieve here is clearly doomed to fail as it is a product of mid-2022. After a couple of years, the specific tools and methods I am recommending will be woefully out of date. I'm sure the real basics will be the same, but within the same topic, there is always a mix of the adaptable new front-end tools and the locked-in, old back-end services.

In short, I have yet to find a resource, which explains coding, in a way that suits me. So out of frustration, I have made my own.

Also, I use windows...
